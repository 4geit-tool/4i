#!/usr/bin/env python2
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
# Authors:
# Caner Candan <caner@candan.fr>, http://caner.candan.fr
#

import argparse, subprocess, sys, os, shutil, logging
from collections import OrderedDict
from operator import itemgetter
import xml.etree.ElementTree as ET

VERSION = "master"
RESOURCES = ['tool', 'core', 'module', 'project']

LEVELS = OrderedDict([('debug', logging.DEBUG),
                      ('info', logging.INFO),
                      ('warning', logging.WARNING),
                      ('error', logging.ERROR),
                      ('quiet', logging.CRITICAL),])

logger = logging.getLogger("4i")

def is_file_empty(fn):
    return os.stat(fn).st_size == 0

def get_name_branch(item):
    kwds = item.split('_')
    name = '_'.join(kwds[:-1])
    branch = kwds[-1]
    return name, branch

def name_branch_filter((name, branch)):
    if not args.name: return True
    if name != args.name: return False
    if not args.branch: return True
    if branch != args.branch: return False
    return True

def resource_filter(resource):
    return not args.resource or (args.resource and resource == args.resource)

def listdir(path):
    try:
        for name, branch in sorted(map(get_name_branch, os.listdir(path)), key=itemgetter(0)):
            yield name, branch
    except OSError:
        pass

def findall(root, tag):
    return [tuple(x.attrib.values()) for x in root.findall(tag)]

def execute(cmd, piped=True, _input=None, cwd=None):
    logger.debug('execute')
    logger.debug(cmd)
    try:
        if piped:
            p = subprocess.Popen(cmd.split(), cwd=cwd, stdin=subprocess.PIPE,
                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if _input:
                out, err = p.communicate(input=_input)
            else:
                out, err = p.communicate()
            logger.debug(out)
            logger.debug(err)
            return out, err
        else:
            subprocess.call(cmd.split(), cwd=cwd)
    except KeyboardInterrupt:
        print 'Canceled'
        sys.exit(-1)

def build(args):
    logger.debug('build')

    if is_file_empty(args.project_xml):
        logger.error('The project file %s is empty.' % args.project_xml)
        sys.exit(-1)
    
    execute("gsl -a -script:%s/share/4i/script.gsl %s" % \
            (os.environ['FORGEIT_PREFIX'], args.project_xml),
            piped=False)

def create(args):
    logger.debug('create')

    print 'Creating %s resource...' % args.resource
    print '-'*80
    print '{:<60}{:<20}'.format(args.name, args.branch)
    sys.stdout.flush()
    registry_uri = os.environ.get('FORGEIT_%s_REGISTRY_URI' % args.resource.upper())
    if not registry_uri:
        print 'Registry URI not available.'
        sys.exit(-1)
    uri = '%s/%s' % (registry_uri, args.name)
    logger.debug(uri)
    if 'file://' in uri:
        uri_dst = '%s.git' % uri.replace('file://', '')
        if os.path.isdir(uri_dst):
            logger.error('remote %s %s already exists.', args.name, args.resource)
        else:
            out, err = execute('git init --bare %s' % uri_dst)
    dst = '%s/%s/%s_%s' % (os.environ['FORGEIT_RESOURCE_PREFIX'],
                           args.resource, args.name, args.branch)
    logger.debug(dst)
    out, err = execute('git clone -q %s %s' % (uri, dst))
    if 'already exists' in err:
        logger.error('%s (%s) %s already exists.', args.name, args.branch, args.resource)
    if 'Could not read from remote repository' in err:
        logger.error('%s (%s) %s failed to be retrieved.', args.name, args.branch, args.resource)
    if 'not found' in err:
        logger.error('%s (%s) %s is not found.', args.name, args.branch, args.resource)
    if 'empty repository' in err:
        # out, err = execute('git -C %s commit -q --allow-empty -m "+init"' % dst)
        with open('%s/%s.xml' % (dst, args.resource), 'w') as f:
            f.write("""\
<?xml version="1.0"?>
<{2} name="{0}" branch="{1}">
</{2}>\
""".format(args.name, args.branch, args.resource))
        with open('%s/.gitignore' % dst, 'w') as f:
            f.write("""\
build
.cache
root.xml
deprecated
releases\
""")
        out, err = execute('git -C %s add %s.xml .gitignore' % (dst, args.resource))
        out, err = execute('git -C %s commit -q -m "+init"' % dst)
        out, err = execute('git -C %s push -q' % dst)

def _list(args):
    logger.debug('_list')

    for resource in RESOURCES:
        print '{:^80}'.format(resource.upper())
        print 80*'-'
        print '{:<40}{:<20}{:<20}'.format('Name', 'Branch', 'Status')
        print 80*'-'
        path = "%s/%s" % (os.environ['FORGEIT_RESOURCE_PREFIX'], resource)
        for name, branch in listdir(path):
            status = 'ok'
            out, err = execute('git -C %s/%s_%s status' % (path, name, branch))
            if 'Changes not staged for commit' in out:
                status = 'uncommitted'
            elif 'Changes to be committed' in out:
                status = 'uncommitted'
            elif 'Untracked files' in out:
                status = 'untracked'
            elif 'Your branch is ahead' in out:
                status = 'unpushed'
            print '{:<40}{:<20}{:<20}'.format(name, branch, status)
        print

def update_item(resource, name, branch):
    print '{:<60}{:<20}'.format(name, branch)
    sys.stdout.flush()
    out, err = execute('git -C %s/%s/%s_%s pull -q' % \
                       (os.environ['FORGEIT_RESOURCE_PREFIX'],
                        resource, name, branch))

def update(args):
    logger.debug('update')
    
    for resource in filter(resource_filter, RESOURCES):
        print 'Updating %s resource...' % resource
        print '-'*80
        path = "%s/%s" % (os.environ['FORGEIT_RESOURCE_PREFIX'], resource)
        for name, branch in filter(name_branch_filter, listdir(path)):
            update_item(resource, name, branch)
        print

def retrieve(args):
    logger.debug('retrieve')

    print 'Retrieving %s resource...' % args.resource
    print '-'*80
    print '{:<60}{:<20}'.format(args.name, args.branch)
    sys.stdout.flush()
    registry_uri = os.environ.get('FORGEIT_%s_REGISTRY_URI' % args.resource.upper())
    if not registry_uri:
        print 'Registry URI not available.'
        sys.exit(-1)
    uri = '%s/%s' % (registry_uri, args.name)
    logger.debug(uri)
    dst = '%s/%s/%s_%s' % (os.environ['FORGEIT_RESOURCE_PREFIX'],
                           args.resource, args.name, args.branch)
    logger.debug(dst)
    out, err = execute('git clone -q -b %s %s %s' % (args.branch, uri, dst))
    if 'already exists' in err:
        logger.error('%s (%s) %s already exists.', args.name, args.branch, args.resource)
    if 'Could not read from remote repository' in err:
        logger.error('%s (%s) %s failed to be retrieved.', args.name, args.branch, args.resource)
    if 'not found' in err:
        logger.error('%s (%s) %s is not found.', args.name, args.branch, args.resource)

def bootstrap(args):
    logger.debug('bootstrap')
    execute('./build/%s/bootstrap.sh' % args.project, piped=False)

def run(args):
    logger.debug('run')
    execute('./build/%s/run.sh %s' % (args.project, args.module), piped=False)

def command(args):
    logger.debug('command')
    execute('./build/%s/%s_command.sh %s' % (args.project, args.module, ' '.join(args.command)), piped=False)

def clean(args):
    logger.debug('clean')
    print 'Cleaning up the building directory...'
    try:
        shutil.rmtree('./build')
    except OSError:
        pass

def clean_resources(args):
    logger.debug('clean_resources')
    for resource in RESOURCES:
        print 'Cleaning up %s resources...' % resource
        try:
            shutil.rmtree('%s/%s' % (os.environ['FORGEIT_RESOURCE_PREFIX'], resource))
        except OSError:
            pass

def test_list(args):
    print '{:^80}'.format("%s (%s)" % (resource_name.upper(), resource_branch))
    print 80*'-'
    print '{:<20}{:<60}'.format('Name', 'Description')
    print 80*'-'
    sys.stdout.flush()
    for test_name, test_description in test_nodes:
        print '{:<20}{:<60}'.format(test_name, test_description)
    print

def test_run(args):
    print 'Testing %s module (%s)...' % (resource_name, resource_branch)
    print '-'*80
    sys.stdout.flush()

    test_filter = lambda (n,d): not args.tests or (args.tests and n in args.tests)

    for test_name, test_description in filter(test_filter, test_nodes):
        print '{:<75}'.format(test_name),

        test_path = '%s/%s_%s/tests/%s' % (resource_path, resource_name, resource_branch, test_name)
        build_path = '/tmp/.4geit/module/%s_%s/tests/%s' % (resource_name, resource_branch, test_name)

        shutil.rmtree(build_path)
        shutil.copytree(test_path, build_path)

        out, err = execute("gsl -a -script:%s/share/4i/script.gsl project.xml" % os.environ['FORGEIT_PREFIX'], piped=True, cwd=build_path)

        with open('%s/out.txt' % build_path, 'w') as f:
            f.write(out)
        with open('%s/err.txt' % build_path, 'w') as f:
            f.write(err)

        print '{:<5}'.format('ok')
        sys.stdout.flush()
    print    
    
def test(args):
    logger.debug('test')
    
    resource_path = "%s/%s" % (os.environ['FORGEIT_RESOURCE_PREFIX'], 'module')
    for resource_name, resource_branch in filter(name_branch_filter, listdir(resource_path)):
        resource_xml_path = "%s/%s_%s/module.xml" % (resource_path, resource_name, resource_branch)

        try:
            tree = ET.parse(resource_xml_path)
            root = tree.getroot()

            test_nodes = findall(root, 'test')
            if not test_nodes:
                continue

            if args.list:
                test_list(args, test_nodes, resource_name, resource_branch)
            else:
                test_run(args, root, test_nodes, resource_path)
        except IOError:
            pass

if __name__ == '__main__':
    common_options = {'formatter_class': argparse.ArgumentDefaultsHelpFormatter}

    parser = argparse.ArgumentParser(description='4i model-oriented programming compiler.', **common_options)

    parser.add_argument('--verbose', '-v', choices=list(LEVELS), default='error', help='Set a verbosity level.')
    parser.add_argument('--levels', '-l', action='store_true', default=False, help='List all the verbosity levels.')
    parser.add_argument('--output', '-o', help='all the logging messages are redirected to the specified filename.')
    parser.add_argument('--debug', '-d', action='store_const', const='debug', dest='verbose', help='Display all the messages.')
    parser.add_argument('--info', '-i', action='store_const', const='info', dest='verbose', help='Display the info messages.')
    parser.add_argument('--warning', '-w', action='store_const', const='warning', dest='verbose', help='Only display the warning and error messages.')
    parser.add_argument('--error', '-e', action='store_const', const='error', dest='verbose', help='Only display the error messages.')
    parser.add_argument('--quiet', '-q', action='store_const', const='quiet', dest='verbose', help='Quiet level of verbosity only displaying the critical error messages.')
    parser.add_argument('--version', '-V', action='store_true', default=False, help='Show the version of 4i.')
    parser.add_argument('--prefix', help='Set the prefix path.')
    parser.add_argument('--resource_prefix', help='Set the resource prefix path.')

    subparsers = parser.add_subparsers(help='Sub-command help.')

    sp = subparsers.add_parser('build', help='Build a project xml file.', **common_options)
    sp.add_argument('project_xml', nargs='?', help='Project xml file.', default='project.xml')
    sp.set_defaults(func=build)

    sp = subparsers.add_parser('list', help='List the retrieved resources.', **common_options)
    sp.set_defaults(func=_list)
    
    sp = subparsers.add_parser('clean', help='Clean up the building directory.', **common_options)
    sp.set_defaults(func=clean)

    sp = subparsers.add_parser('clean_resources', help='Clean up the retrieved resources.', **common_options)
    sp.set_defaults(func=clean_resources)

    sp = subparsers.add_parser('create', help='Create a new resource.', **common_options)
    sp.add_argument('name', help='Name of the resource to create.')
    sp.add_argument('branch', nargs='?', help='Branch of the resource to create.', default='master')
    sp.add_argument('resource', nargs='?', choices=RESOURCES, help='Type of the resource to create.', default='module')
    sp.set_defaults(func=create)
    
    sp = subparsers.add_parser('update', help='Update the retrieved resources.', **common_options)
    sp.add_argument('name', nargs='?', help='Name of the specific resource to update.')
    sp.add_argument('branch', nargs='?', help='Branch of the resource to update.')
    sp.add_argument('resource', nargs='?', choices=RESOURCES, help='Type of the resource to update.')
    sp.set_defaults(func=update)

    sp = subparsers.add_parser('retrieve', help='Retrieve resources.', **common_options)
    sp.add_argument('name', help='Name of the specific resource to retrieve.')
    sp.add_argument('branch', nargs='?', help='Branch of the resource to retrieve.', default='master')
    sp.add_argument('resource', nargs='?', choices=RESOURCES, help='Type of the resource to retrieve.', default='module')
    sp.set_defaults(func=retrieve)

    sp = subparsers.add_parser('bootstrap', help='Use the post-processing bootstrapping script.', **common_options)
    sp.add_argument('project', help='Name of the project.')
    sp.set_defaults(func=bootstrap)

    sp = subparsers.add_parser('run', help='Use the post-processing running script.', **common_options)
    sp.add_argument('project', help='Name of the project.')
    sp.add_argument('module', help='Name of the module.')
    sp.set_defaults(func=run)

    sp = subparsers.add_parser('command', help='Use the post-processing command script.', **common_options)
    sp.add_argument('project', help='Name of the project.')
    sp.add_argument('module', help='Name of the module.')
    sp.add_argument('command', nargs='+', help='The command line to execute.')
    sp.set_defaults(func=command)

    sp = subparsers.add_parser('test', help='Test modules.', **common_options)
    sp.add_argument('name', nargs='?', help='Name of the module to test.')
    sp.add_argument('branch', nargs='?', help='Branch of the module to test.', default='master')
    sp.add_argument('tests', nargs='*', help='Name(s) of the test(s).')
    sp.add_argument('--list', '-l', action='store_true', default=False, help='Display a list of the available tests.')
    sp.set_defaults(func=test)

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    if args.levels:
        print "Here's the verbose levels available:"
        for keys in LEVELS.keys():
            print "\t%s" % keys
        sys.exit()

    if args.output:
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
            filename=args.output, filemode='a'
            )
    else:
        logging.basicConfig(
            level=LEVELS.get(args.verbose, logging.NOTSET),
            format='%(name)-12s: %(levelname)-8s %(message)s'
        )

    logger.debug(args)

    if args.version:
        print VERSION
        sys.exit()

    os.environ['FORGEIT_PREFIX'] = args.prefix if args.prefix else \
                                   '/'.join(sys.argv[0].split('/')[:-2])
    os.environ['FORGEIT_RESOURCE_PREFIX'] = args.resource_prefix if args.resource_prefix else \
                                            "%s/.4geit" % os.environ['HOME']

    if 'func' not in args:
        parser.print_help()
        sys.exit()

    args.func(args)

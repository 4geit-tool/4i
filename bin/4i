#!/usr/bin/env python2
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
# Authors:
# Caner Candan <caner@candan.fr>, http://caner.candan.fr
#

import argparse, subprocess, sys, os, shutil, logging
from collections import OrderedDict
from operator import itemgetter

VERSION = "master"
RESOURCES = ['tool', 'core', 'module', 'project']

LEVELS = OrderedDict([('debug', logging.DEBUG),
                      ('info', logging.INFO),
                      ('warning', logging.WARNING),
                      ('error', logging.ERROR),
                      ('quiet', logging.CRITICAL),])

logger = logging.getLogger("4i")

def is_file_empty(fn):
    return os.stat(fn).st_size == 0

def execute(cmd, piped=True, _input=None):
    logger.debug('execute')
    logger.debug(cmd)
    try:
        if piped:
            p = subprocess.Popen(cmd.split(), stdin=subprocess.PIPE,
                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if _input:
                out, err = p.communicate(input=_input)
            else:
                out, err = p.communicate()
            logger.debug(out)
            logger.debug(err)
            return out, err
        else:
            subprocess.call(cmd.split())
    except KeyboardInterrupt:
        print('Canceled')
        sys.exit(-1)

def get_name_branch(item):
    kwds = item.split('_')
    name = '_'.join(kwds[:-1])
    branch = kwds[-1]
    return name, branch

def listdir(path):
    try:
        for name, branch in sorted(map(get_name_branch, os.listdir(path)), key=itemgetter(0)):
            yield name, branch
    except OSError:
        pass

def build(args):
    logger.debug('build')

    if is_file_empty(args.project_xml):
        logger.error('The project file %s is empty.' % args.project_xml)
        sys.exit(-1)
    
    execute("gsl -a -script:%s/share/4i/script.gsl %s" % \
            (os.environ['FORGEIT_PREFIX'], args.project_xml),
            piped=False)

def create(args):
    logger.debug('create')

    print('Creating %s resource...' % args.resource)
    print('-'*80)
    print('{:<60}{:<20}'.format(args.name, args.branch))
    sys.stdout.flush()
    registry_uri = os.environ.get('FORGEIT_%s_REGISTRY_URI' % args.resource.upper())
    if not registry_uri:
        print('Registry URI not available.')
        sys.exit(-1)
    uri = '%s/%s' % (registry_uri, args.name)
    logger.debug(uri)
    if 'file://' in uri:
        uri_dst = '%s.git' % uri.replace('file://', '')
        if os.path.isdir(uri_dst):
            logger.error('remote %s %s already exists.', args.name, args.resource)
        else:
            out, err = execute('git init --bare %s' % uri_dst)
    dst = '%s/%s/%s_%s' % (os.environ['FORGEIT_RESOURCE_PREFIX'],
                           args.resource, args.name, args.branch)
    logger.debug(dst)
    out, err = execute('git clone -q %s %s' % (uri, dst))
    if 'already exists' in err:
        logger.error('%s (%s) %s already exists.', args.name, args.branch, args.resource)
    if 'Could not read from remote repository' in err:
        logger.error('%s (%s) %s failed to be retrieved.', args.name, args.branch, args.resource)
    if 'not found' in err:
        logger.error('%s (%s) %s is not found.', args.name, args.branch, args.resource)
    if 'empty repository' in err:
        # out, err = execute('git -C %s commit -q --allow-empty -m "+init"' % dst)
        with open('%s/%s.xml' % (dst, args.resource), 'w') as f:
            f.write("""\
<?xml version="1.0"?>
<{2} name="{0}" branch="{1}">
</{2}>\
""".format(args.name, args.branch, args.resource))
        with open('%s/.gitignore' % dst, 'w') as f:
            f.write("""\
build
.cache
root.xml
deprecated
releases\
""")
        out, err = execute('git -C %s add %s.xml .gitignore' % (dst, args.resource))
        out, err = execute('git -C %s commit -q -m "+init"' % dst)
        out, err = execute('git -C %s push -q' % dst)

def _list(args):
    logger.debug('_list')

    for resource in RESOURCES:
        dashes = (40+20+20)*'-'
        print('%40s' % resource.upper())
        print(dashes)
        print('{:<40}{:<20}{:<20}'.format('Name', 'Branch', 'Status'))
        print(dashes)
        path = "%s/%s" % (os.environ['FORGEIT_RESOURCE_PREFIX'], resource)
        for name, branch in listdir(path):
            status = 'ok'
            out, err = execute('git -C %s/%s_%s status' % (path, name, branch))
            if 'Changes not staged for commit' in out:
                status = 'uncommitted'
            elif 'Changes to be committed' in out:
                status = 'uncommitted'
            elif 'Untracked files' in out:
                status = 'untracked'
            elif 'Your branch is ahead' in out:
                status = 'unpushed'
            print('{:<40}{:<20}{:<20}'.format(name, branch, status))
        print('')

def update_item(resource, name, branch):
    print('{:<60}{:<20}'.format(name, branch))
    sys.stdout.flush()
    out, err = execute('git -C %s/%s/%s_%s pull -q' % \
                       (os.environ['FORGEIT_RESOURCE_PREFIX'],
                        resource, name, branch))

def update(args):
    logger.debug('update')
    
    resource_filter = lambda r: not args.resource or (args.resource and r == args.resource)
    name_branch_filter = lambda (n,b): not args.name or (args.name and n == args.name and \
                          (not args.branch or (args.branch and b == args.branch)))
    
    for resource in filter(resource_filter, RESOURCES):
        print('Updating %s resource...' % resource)
        print('-'*80)
        path = "%s/%s" % (os.environ['FORGEIT_RESOURCE_PREFIX'], resource)
        for name, branch in filter(name_branch_filter, listdir(path)):
            update_item(resource, name, branch)
        print('')

def retrieve(args):
    logger.debug('retrieve')

    print('Retrieving %s resource...' % args.resource)
    print('-'*80)
    print('{:<60}{:<20}'.format(args.name, args.branch))
    sys.stdout.flush()
    registry_uri = os.environ.get('FORGEIT_%s_REGISTRY_URI' % args.resource.upper())
    if not registry_uri:
        print('Registry URI not available.')
        sys.exit(-1)
    uri = '%s/%s' % (registry_uri, args.name)
    logger.debug(uri)
    dst = '%s/%s/%s_%s' % (os.environ['FORGEIT_RESOURCE_PREFIX'],
                           args.resource, args.name, args.branch)
    logger.debug(dst)
    out, err = execute('git clone -q -b %s %s %s' % (args.branch, uri, dst))
    if 'already exists' in err:
        logger.error('%s (%s) %s already exists.', args.name, args.branch, args.resource)
    if 'Could not read from remote repository' in err:
        logger.error('%s (%s) %s failed to be retrieved.', args.name, args.branch, args.resource)
    if 'not found' in err:
        logger.error('%s (%s) %s is not found.', args.name, args.branch, args.resource)

def bootstrap(args):
    logger.debug('bootstrap')
    execute('./build/%s/bootstrap.sh' % args.project, piped=False)

def run(args):
    logger.debug('run')
    execute('./build/%s/run.sh %s' % (args.project, args.module), piped=False)

def command(args):
    logger.debug('command')
    execute('./build/%s/%s_command.sh %s' % (args.project, args.module, ' '.join(args.command)), piped=False)

def clean(args):
    logger.debug('clean')
    print('Cleaning up the building directory...')
    try:
        shutil.rmtree('./build')
    except OSError:
        pass

def clean_resources(args):
    logger.debug('clean_resources')
    for resource in RESOURCES:
        print('Cleaning up %s resources...' % resource)
        try:
            shutil.rmtree('%s/%s' % (os.environ['FORGEIT_RESOURCE_PREFIX'], resource))
        except OSError:
            pass

if __name__ == '__main__':
    common_options = {'formatter_class': argparse.ArgumentDefaultsHelpFormatter}

    parser = argparse.ArgumentParser(description='4i model-oriented programming compiler.', **common_options)

    parser.add_argument('--verbose', '-v', choices=list(LEVELS), default='error', help='Set a verbosity level.')
    parser.add_argument('--levels', '-l', action='store_true', default=False, help='List all the verbosity levels.')
    parser.add_argument('--output', '-o', help='all the logging messages are redirected to the specified filename.')
    parser.add_argument('--debug', '-d', action='store_const', const='debug', dest='verbose', help='Display all the messages.')
    parser.add_argument('--info', '-i', action='store_const', const='info', dest='verbose', help='Display the info messages.')
    parser.add_argument('--warning', '-w', action='store_const', const='warning', dest='verbose', help='Only display the warning and error messages.')
    parser.add_argument('--error', '-e', action='store_const', const='error', dest='verbose', help='Only display the error messages.')
    parser.add_argument('--quiet', '-q', action='store_const', const='quiet', dest='verbose', help='Quiet level of verbosity only displaying the critical error messages.')
    parser.add_argument('--version', '-V', action='store_true', default=False, help='Show the version of 4i.')
    parser.add_argument('--prefix', help='Set the prefix path.')
    parser.add_argument('--resource_prefix', help='Set the resource prefix path.')

    subparsers = parser.add_subparsers(help='Sub-command help.')

    sp = subparsers.add_parser('build', help='Build a project xml file.', **common_options)
    sp.add_argument('project_xml', nargs='?', help='Project xml file.', default='project.xml')
    sp.set_defaults(func=build)

    sp = subparsers.add_parser('list', help='List the retrieved resources.', **common_options)
    sp.set_defaults(func=_list)
    
    sp = subparsers.add_parser('clean', help='Clean up the building directory.', **common_options)
    sp.set_defaults(func=clean)

    sp = subparsers.add_parser('clean_resources', help='Clean up the retrieved resources.', **common_options)
    sp.set_defaults(func=clean_resources)

    sp = subparsers.add_parser('create', help='Create a new resource.', **common_options)
    sp.add_argument('name', help='Name of the resource to create.')
    sp.add_argument('branch', nargs='?', help='Branch of the resource to create.', default='master')
    sp.add_argument('resource', nargs='?', choices=RESOURCES, help='Type of the resource to create.', default='module')
    sp.set_defaults(func=create)
    
    sp = subparsers.add_parser('update', help='Update the retrieved resources.', **common_options)
    sp.add_argument('name', nargs='?', help='Name of the specific resource to update.')
    sp.add_argument('branch', nargs='?', help='Branch of the resource to update.')
    sp.add_argument('resource', nargs='?', choices=RESOURCES, help='Type of the resource to update.')
    sp.set_defaults(func=update)

    sp = subparsers.add_parser('retrieve', help='Retrieve resources.', **common_options)
    sp.add_argument('name', help='Name of the specific resource to retrieve.')
    sp.add_argument('branch', nargs='?', help='Branch of the resource to retrieve.', default='master')
    sp.add_argument('resource', nargs='?', choices=RESOURCES, help='Type of the resource to retrieve.', default='module')
    sp.set_defaults(func=retrieve)

    sp = subparsers.add_parser('bootstrap', help='Use the post-processing bootstrapping script.', **common_options)
    sp.add_argument('project', help='Name of the project.')
    sp.set_defaults(func=bootstrap)

    sp = subparsers.add_parser('run', help='Use the post-processing running script.', **common_options)
    sp.add_argument('project', help='Name of the project.')
    sp.add_argument('module', help='Name of the module.')
    sp.set_defaults(func=run)

    sp = subparsers.add_parser('command', help='Use the post-processing command script.', **common_options)
    sp.add_argument('project', help='Name of the project.')
    sp.add_argument('module', help='Name of the module.')
    sp.add_argument('command', nargs='+', help='The command line to execute.')
    sp.set_defaults(func=command)
    
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    if args.levels:
        print("Here's the verbose levels available:")
        for keys in LEVELS.keys():
            print("\t%s" % keys)
        sys.exit()

    if args.output:
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
            filename=args.output, filemode='a'
            )
    else:
        logging.basicConfig(
            level=LEVELS.get(args.verbose, logging.NOTSET),
            format='%(name)-12s: %(levelname)-8s %(message)s'
        )

    logger.debug(args)

    if args.version:
        print(VERSION)
        sys.exit()

    os.environ['FORGEIT_PREFIX'] = args.prefix if args.prefix else \
                                   '/'.join(sys.argv[0].split('/')[:-2])
    os.environ['FORGEIT_RESOURCE_PREFIX'] = args.resource_prefix if args.resource_prefix else \
                                            "%s/.4geit" % os.environ['HOME']

    if 'func' not in args:
        parser.print_help()
        sys.exit()

    args.func(args)
